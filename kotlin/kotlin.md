PART2. 코틀린답게 사용하기

7. 연산자 오버로딩과 기타관례

7.1 산술연산자 오버로딩
``` txt
operator 키워드를 사용하여 함수를 정의하면 연산자 오버로딩이 가능합니다. 코틀린 연산자가 자동으로 교환법칙을 지원하지는 않기 때문에 원하는 연산형태에 대해서는 정의해야만 합니다.

식	함수이름
a * b	times
a / b	div
a % b	mod(1.1부터 rem)
a + b	plus
a - b	minus
```

위의 표와 같은 형식으로 복합대입연산자(+=)와 단항연산자오버로딩도 구현할 수 있습니다.

7.2 비교연산자 오버로딩
```
equals
 코틀린은 == 또는 != 연산자 호출은 equals 메소드 호출로 컴파일을 합니다. 객체 참조비교는 === 연산자를 사용합니다. equals는 Any에 정의된 메소드이므로 override가 필요합니다.

compareTo
 Comparable 인터페이스를 구현하여 compareTo 메소드를  override 해야함은 자바와 동일하지만 코틀린은 비교연산자(<.>,<=,>=)를 사용하면 compareTo 호출로 컴파일되는 기능?을 제공합니다.
```

7.3 컬렉션과 범위에 대해 쓸 수 있는 관례
```
-	operator로 get/set을 구현하여 [](인덱스 연산자)로 사용할 수 있다.
-	operator로 contains를 구현하여 in 을 사용할 수 있다.
-	operator로 rangeTo를 구현하여 .. 을 사용할 수 있다.
-	operator로 iterator()를 구현하여 for문에서 사용할 수 있다.
```

7.4 구조분해선언( destrucring declaration )
```
 구조분해를 사용하면 복합적인 값을 분해해서 여러 다른 변수를 한꺼번에 초기화할 수 있다. (1) data 클래스의 주 생성자에 들어있는 프로퍼티에 대해서는 컴파일러가 자동으로 componentN[1..5] 함수를 만들어준다. (2) for 루프 변수에 구조분해선언을 사용할 수 있다.
```

7.5 위임프로퍼티(프로퍼티 접근자 로직 재활용)
```
 by 키워드를 사용하여 delegate 할 클래스를 프로퍼티에 선언하여 사용합니다. 이러한 위임객체를 통해서 단순히 값이 아닌 더 복잡한 동작을 프로퍼티를 통해 구현할 수 있습니다. 또한 지연초기화(lazy initialization)를 위해서 backing-property 기법을 사용하는 대신에, by 키워드를 lazy() 함수와 사용하여 thread-safe하게 지연초기화를 구현할 수 있습니다.
```

8. 고차함수(high order function): 파라미터와 반환 값으로 람다 사용

8.1 고차함수정의
```
 고차함수는 다른함수를 인자로 받거나 함수를 반환하는 함수인데 코틀린에서는 람다나 함수참조를 사용하여 구현합니다. 변수에 함수타입을 선언하거나 함수의 파라미터에 함수타입을 선언하여 사용합니다. (함수타입은 invoke 메소드를 구현하는 인터페이스입니다.)
 로컬변수에 람다식을 대입할 경우 람다식의 파라미터에 타입이 정의되어 있을 경우 코틀린의 타입 추론에 의해 변수에 함수타입을 지정하지 않아도 됩니다. 반대로 변수타입에 함수타입을 명식적으로 선언하면 굳이 람다식에 파라미터 타입을 적을 필요는 없습니다.
 함수의 파라미터에 선언할 경우에는 파라미터 타입으로 함수타입을 선언한 후에 해당 파라미터를 호출하면 됩니다. 함수타입의 파라미터에 이름을 붙여도되고 안 붙여도 되며 디폴트값을 지정할 수도 있다. 함수를 반환하는 함수는 반환타입에 함수타입을 선언하고 람다나 멤버참조를 반환하여 구현할 수 있습니다.
```

8.2 인라인함수 : 람다의 부가 비용 없애기
 람다식이 변수를 포획할 때 새로운 익명 클래스 객체가 생성되면서 부가 비용이 발생하게 됩니다. inline 키워드를 사용하면 컴파일러가 인라인 함수를 호출하는 모든 문장을 함수 본문에 해당하는 바이트코드로 바꿔치기 해줍니다. inline은 코드는 길어질 수 있지만 성능을 향상시켜 줄 수 있습니다.

 인라인 함수에 람다로 넘길 인자나 람다실행 구문이 없다면 컴파일러가 경고 메시지를 줄 것입니다. 그리고 인라인 함수에 람다 인자가 2개 이상일 때 noline 키워드로 인라인을 금지시킬 수 있습니다. 코틀린에서 제공하는 인라인된 함수는 filter, map 과 같은 것과 java7의 try-with-resource와 같은 use함수를 제공하고 있습니다.


8.3 고차함수 안에서 흐름제어
```
 람다 안에서 return을 사용하면 람다로부터만 반환되는 게 아니라 그 람다를 호출하는 함수가 실행을 끝내고 반환된다. 그렇게 자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는 return문을 non-local return이라 부른다. return이 바깥쪽 함수를 반환시킬 수 있는 때는 람다를 인자로 받는 함수가 인라인 함수인 경우입니다.
 또한 람다식에서도 lable 키워드나 인라인함수의 이름을 사용하여  local-return을 사용할 수 있습니다. 람다 대신에 익명(무명)함수를 사용하여 non-local return을 여럿 사용해야 하는 코드블록을 쉽게 작성할 수 있다. 일반함수와 익명(무명)함수의 차이는 함수이름이나 파라미터 타입을 생략할 수 있다는 점 입니다.
```

9. 제네릭스

9.1 제네릭 타입 파라미터
```
 코틀린의 제네릭은 타입파라미터  <T>(angle brackets)를 붙여 함수, 확장프라퍼티, 클래스에서 사용할 수 있습니다. 자바와는 다르게 코틀린은 제네릭타입의 타입인자를 명시하거나 컴파일러가 추론할 수 있는 형태로 구현해야 합니다.
 함수에서 타입파라미터 <T>는  수신객체와 반환타입에 사용됩니다. 확장프라퍼티도 동일하게 제네릭을 구현할 수 있지만, 클래스 프라퍼티에 여러 값을 저장할 수 는 없으므로 일반프라퍼티는 타입파라미터를 가질 수 없습니다.
 클래스 뒤에 <T>를 붙이면 클래스도 제네릭하게 만들 수 있습니다. 그렇게하면 클래스 안에서 타입파라미터를 일반 타입처럼 사용할 수 있습니다. 이러한 제네릭 클래스를 상속하여 오버라이드하는 메소드에서는 명시적으로 타입 인자를 지정해야 합니다. 
 또한 콜론(:)을 사용하여 타입파라미터에 제약을 줄 수 있으며, Any를 타입파라미터로 지정하면 타입인자로 Null이 되지 않도록 지정할 수 있습니다.(타입파라미터의 상한은 Any?와 같다고 보면 된다. <T : Any?>)
```

9.2 실행 시 제네릭스의 동작: 소거된 파라미터와 실체화된 타입 파라미터
```
 JVM 제네릭스는 보통 타입소거(type erasure)를 사용해 구현된다. 이는 실행 시점에 제네릭 클래스의 인스턴스에 타입 인자 정보가 들어있지 않다는 뜻이다. 코틀린 제네릭 타입 인자 정보는 런타임에 지워진다. 이는 제네릭 클래스 인스턴스가 그 인스턴스를 생성할 때 쓰인 타입 인자에 대한 정보를 유지하지 않는다는 뜻입니다. 그래서 실행시점에 타입인자를 검사할 수 없다. 예를 들어 is 검사에서 타입 인자로 지정한 타입을 검사할 수 없습니다. 이런 경우에는 스타프로젝션(star projection)을 사용하면 됩니다.
 하지만 inline함수의 타입 파라미터는 실체화되므로 실행 시점에 인라인 함수의 타입 인자를 알 수 있습니다. inline함수와 함께 제네릭 <T>를 reified 키워드를 사용하여 <reified T>로 정의하면 컴파일러는 타입 인자로 쓰인 구체적인 클래스를 참조하는 바이트코드를 생성해 삽입할 수 있습니다.
```

9.3 변성(Variance): 제네릭과 하위 타입
```
 코틀린에는 자바와 똑같은 와일드카드는 없지만, variance 그리고 declaration-site variance 와 type projection 의 개념으로 구현하고 있습니다. 먼저 변성(Variance)은 List<Any>와 List<String>과 같이 base-type이 같고 타입인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념입니다.

 제네릭 타입의 인스턴스들 사이에 하위타입 관계가 성립하지 않으면 그 제네렉 타입을 invariant(무공변)
이라고 말합니다. 반면에 어떤 클래스A가 클래스B의 sub-type이면 List<A>는 List<B>의 하위타입 일  경우 이러한 클래스나 인터페이스를 covariant(공변적-공변성)이라고 말합니다. 이와는 반대로 타입 인자의 하위 타입 관계가 제네릭 타입에서 뒤집힌 관계 타입은 contravariance(반공변성)라고 합니다.

 자바에서는 모든 클래스가 invariant이기 때문에 <? extends T>와 같이 사용하고, 코틀린에서 out 키워드를 사용하여 <out T>처럼 사용하여 covariant하게 하위 타입 관계가(upper bound, extends
-bound) 유지될 수 있도록 할 수 있습니다. 반대로 자바에서 <? super T>는 코틀린에서 <in T>와 같이 사용하여 contravariance를 구현할 수 있도록 합니다.
 이러한 개념은 최대한의 유연성과 타입안전성을 위함이며, Producer로부터는 읽는 객체들만 호출할 수 있고, Consumer로부터는 쓰는 객체들만 호출할 수 있음을 나타냅니다. (Producer-Extends-Consu
mer-Super) out과 in은 위치가 정해져 있어서 함수 파라미터 타입은 in을 함수 반환 타입은 out 위치에만 사용할 수 있습니다.

 코틀린의 declaration-site-variance(선언지점변성)은 클래스를 선언하면서 <out T> 또는 <in T>을 지정하면 그 클래스를 사용하는 모든 장소에서 변성 지정자가 적용되는 방식입니다.
 타입프로젝션은 자바의 use-site-variance(사용지점변성)의 코틀린 버전으로 보면 됩니다. 제네릭 클래스의 메소드 함수파라미터에 <out T> 또는 <in T>을 사용하여 구현할 수 있습니다. 또한 스타프로젝션을 제공하여 제네릭 타입 인자가 어떤 타입인지 정보가 없거나 중요하지 않음을(알 필요가 없을 때) 표현할 때 사용하고 있습니다.

* 생성자 파라미터는 인이나 아웃 어느 쪽도 아니라는 사실에 유의하라.
```

10.  애노테이션과 리플렉션
```
코틀린 컴파일러는 자바어노테이션을 100% 컴파일 합니다. 코틀린 커스텀 애노테이션을 만드려면 먼저 class 앞에 ‘annotation’ modifier를 붙여서 선언하며 그 위에 @Target, @Retention, @Repeatable, @MustBeDocumented 를 사용하여 구성할 수 있습니다. 사용할 때는 애노테이션 이름 앞에 ‘@’를 붙여서 클래스나 함수 앞에 또는 함수의 인자 앞, 생성자 프로퍼티에 같이 사용할 수 있습니다. 프로퍼티나 기본 생성자의 매개변수에 애노테이션을 추가할 때 use-site target(사용지점대상)을 지정하여 어떤 요소에 애노테이션을 지원할지 지정할 수 있는 목록을 제공하고 있습니다.
```

11. DSL(Domain Specific Language) 만들기.
```
 모든 프로그래밍 언어는 GPL(General Purpose Language)와 DSL(Domain Specific language)로 나누어질 수 있습니다. DSL은 말 그대로 특정 애플리케이션 도메인에 특화된 컴퓨터 언어로서 SQL, 정규식 또는 build.gradle이 예가 될 수 있습니다. DSL을 사용하기에 적절한 부분은 configuration-class나(Ktor) 사용자가 모델을 인식할 필요가 없는 라이브러리 인터페이스가(HTML Builder, Anko) 있습니다.
 GPL과 DSL은 서로 이질적이기 때문에 함께 사용하기 어려운 단점이 있는데 이런 문제를 해결하고자 internal DSL 이라는 개념이 생겨나게 되었습니다. internal DSL은 GPL과 동일한 언어를 사용하면서 DSL의 장점을 살리는데 코틀린에서도 ‘Lambda out of parentheses’, ‘Lambda with receiver’, ‘Extension Function’등과 같은 DSL을 제공하고 있습니다.

ref) 
https://proandroiddev.com/writing-dsls-in-kotlin-part-1-7f5d2193f277
https://dzone.com/articles/kotlin-dsl-from-theory-to-practice
```
